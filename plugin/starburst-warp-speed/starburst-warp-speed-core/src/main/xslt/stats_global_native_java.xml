<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:output method="text" encoding="utf-8" indent="no" />

    <xsl:include href="templates/templates.xsl" />
    <xsl:output method="text" encoding="utf-8" indent="no" />

    <xsl:template match="Object">
        <xsl:variable name="num_counters">
            <xsl:value-of select="count(//Counter)" />
        </xsl:variable>
        <!-- output license -->
        <xsl:call-template name="License" />

        <!-- output package, class header  and imports -->
        <xsl:text>package io.trino.plugin.warp.gen.stats;&#10;</xsl:text>
        <xsl:text>&#10;</xsl:text>
        <xsl:text>import com.fasterxml.jackson.annotation.JsonCreator;&#10;</xsl:text>
        <xsl:text>import com.fasterxml.jackson.annotation.JsonIgnore;&#10;</xsl:text>
        <xsl:text>import com.fasterxml.jackson.annotation.JsonProperty;&#10;</xsl:text>
        <xsl:text>import io.trino.plugin.varada.metrics.VaradaStatType;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import io.trino.plugin.varada.metrics.VaradaStatsBase;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import org.weakref.jmx.Managed;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:call-template name="NewLine" />
        <xsl:text>import java.nio.ByteBuffer;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import java.nio.ByteOrder;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import java.nio.LongBuffer;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import java.util.HashMap;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>import java.util.Map;</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:call-template name="NewLine" />

        <xsl:text>@SuppressWarnings({"checkstyle:MemberName", "checkstyle:ParameterName"})</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>public final class VaradaStats</xsl:text>
        <xsl:call-template name="Capitalize">
            <xsl:with-param name="s">
                <xsl:value-of select="substring(@Name, 1, 1)" />
            </xsl:with-param>
        </xsl:call-template>
        <xsl:value-of select="substring(@Name, 2)" />
        <xsl:call-template name="NewLine" />
        <xsl:text>        extends VaradaStatsBase</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>{</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>    /* This class file is auto-generated from </xsl:text><xsl:value-of select="@Name" />
        <xsl:text> xml file for statistics and counters */&#10;</xsl:text>
        <!-- output class members -->
        <xsl:text>    private final LongBuffer longStruct;&#10;&#10;</xsl:text>

        <xsl:choose>
            <xsl:when test="count(Counter) > 0 ">
                <xsl:text>    @JsonCreator&#10;</xsl:text>
                <xsl:text>    public VaradaStats</xsl:text>
                <xsl:call-template name="Capitalize">
                    <xsl:with-param name="s">
                        <xsl:value-of select="substring(@Name, 1, 1)" />
                    </xsl:with-param>
                </xsl:call-template>
                <xsl:value-of select="substring(@Name, 2)" />
                <xsl:text>(</xsl:text>

                <xsl:for-each select="Counter">
                    <xsl:call-template name="createConstructorParams" />
                </xsl:for-each>

                <xsl:text>)&#10;    {&#10;</xsl:text>
                <xsl:text>        this();&#10;</xsl:text>
                <xsl:for-each select="Counter">
                    <xsl:call-template name="createConstructorFields">
                        <xsl:with-param name="Offset">
                            <xsl:value-of select="0" />
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:for-each>
                <xsl:text>    }&#10;&#10;</xsl:text>
            </xsl:when>
        </xsl:choose>
        <!-- output CTOR -->
        <xsl:text>    public VaradaStats</xsl:text>
        <xsl:call-template name="Capitalize">
            <xsl:with-param name="s">
                <xsl:value-of select="substring(@Name, 1, 1)" />
            </xsl:with-param>
        </xsl:call-template>
        <xsl:value-of select="substring(@Name, 2)" />
        <xsl:text>()&#10;    {&#10;</xsl:text>
        <xsl:text>        super("</xsl:text>
        <xsl:value-of select="@Name" />
        <xsl:text>", VaradaStatType.Worker);</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:call-template name="NewLine" />
        <xsl:text>        ByteBuffer rawStruct = initNative(1);&#10;</xsl:text>
        <xsl:text>        rawStruct.order(ByteOrder.LITTLE_ENDIAN);&#10;</xsl:text>
        <xsl:text>        longStruct = rawStruct.asLongBuffer();&#10;    }&#10;&#10;</xsl:text>
        <!-- output the managed getter methods -->
        <xsl:for-each select="Counter">
            <xsl:call-template name="OutputCounterManaged">
                <xsl:with-param name="Offset">
                    <xsl:value-of select="0" />
                </xsl:with-param>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:for-each select="Pair">
            <xsl:call-template name="OutputPairManaged">
                <xsl:with-param name="Offset">
                    <xsl:value-of select="$num_counters" />
                </xsl:with-param>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:call-template name="createResetMethod" />
        <xsl:call-template name="createMergeMethod" />
        <xsl:call-template name="createHasPersistentMethod" />
        <xsl:call-template name="statsLoggerMapperMethod" />
        <xsl:call-template name="createNumOfMetricsMethod">
            <xsl:with-param name="num_counters">
                <xsl:value-of select="$num_counters" />
            </xsl:with-param>
        </xsl:call-template>

        <!-- output native initalizer -->
        <xsl:call-template name="NewLine" />
        <xsl:text>    private native ByteBuffer initNative(long limit);&#10;</xsl:text>
        <!-- end -->
        <xsl:text>}&#10;</xsl:text>
    </xsl:template>

    <xsl:template name="OutputCounterManaged">
        <xsl:param name="Offset" />
        <xsl:choose>
            <xsl:when test="@Type='long' or @Type='double'">
                <xsl:call-template name="JsonIgnoreCreator" />
                <xsl:call-template name="JsonPropertyCreator" />
                <xsl:text>    public </xsl:text>
                <xsl:value-of select="@Type" /><xsl:text> get</xsl:text><xsl:value-of select="@Name" />
                <xsl:text>()&#10;    {&#10;        return </xsl:text><xsl:value-of select="@Type" /><xsl:text>Struct.get(</xsl:text>
                <xsl:value-of select="$Offset + position() - 1" /><xsl:text>);&#10;    }&#10;&#10;</xsl:text>
            </xsl:when>
            <xsl:when test="@Type='min' or @Type='max'">
                <xsl:call-template name="JsonIgnoreCreator" />
                <xsl:text>    @JsonProperty("</xsl:text>
                <xsl:value-of select="@Type" /><xsl:text>_</xsl:text><xsl:value-of select="@Name" />
                <xsl:text>")&#10;</xsl:text>
                <xsl:text>    @Managed&#10;</xsl:text>
                <xsl:text>    public long get</xsl:text>
                <xsl:value-of select="@Type" /><xsl:text>_</xsl:text><xsl:value-of select="@Name" />
                <xsl:text>()&#10;    {&#10;        return longStruct.get(</xsl:text>
                <xsl:value-of select="$Offset + position() - 1" /><xsl:text>);&#10;    }&#10;&#10;</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    <xsl:text>ERROR wrong Type </xsl:text><xsl:value-of select="@Type" /><xsl:text> in Counter </xsl:text>
                    <xsl:value-of select="@Name" /><xsl:text>&#13;&#10;</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="OutputPairManaged">
        <xsl:param name="Offset" />
        <xsl:choose>
            <xsl:when test="@Type='avg'">
                <xsl:text>    @Managed&#10;    public double getavg_</xsl:text>
                <xsl:value-of select="@Name" /><xsl:text>()&#10;    {&#10;        if (longStruct.get(</xsl:text>
                <xsl:value-of select="$Offset + 2 * position() - 2" /><xsl:text>) == 0) {&#10;            return 0;&#10;</xsl:text>
                <xsl:text>        }&#10;        return ((double) longStruct.get(</xsl:text>
                <xsl:value-of select="$Offset + 2 * position() - 1" /><xsl:text>)) / ((double) longStruct.get(</xsl:text>
                <xsl:value-of select="$Offset + 2 * position() - 2" /><xsl:text>));&#10;    }&#10;&#10;</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    <xsl:text>ERROR wrong Type </xsl:text><xsl:value-of select="@Type" /><xsl:text> in Counter </xsl:text>
                    <xsl:value-of select="@Name" /><xsl:text>&#13;&#10;</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="createConstructorFields">
        <xsl:param name="Offset" />
        <xsl:text>        longStruct.put(</xsl:text>
        <xsl:value-of select="$Offset + position() - 1" />
        <xsl:text>, </xsl:text>
        <xsl:choose>
            <xsl:when test="@Type='long'">
                <xsl:value-of select="@Name" />
            </xsl:when>
            <xsl:when test=" @Type='double'">
                <xsl:text>(long) </xsl:text><xsl:value-of select="@Name" />
            </xsl:when>
            <xsl:when test="@Type='min' or @Type='max'">
                <xsl:value-of select="@Type" /><xsl:text>_</xsl:text><xsl:value-of select="@Name" />
            </xsl:when>
        </xsl:choose>
        <xsl:text>);</xsl:text>
        <xsl:call-template name="NewLine" />
    </xsl:template>
    <xsl:template name="createResetMethod">
        <xsl:text>    @Override</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>    public void reset()</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>    {</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:for-each select="Counter">
            <xsl:text>        longStruct.put(</xsl:text>
            <xsl:value-of select="position() - 1" />
            <xsl:text>, 0);</xsl:text>
            <xsl:call-template name="NewLine" />
        </xsl:for-each>
        <xsl:text>    }</xsl:text>
        <xsl:call-template name="NewLine" />
    </xsl:template>
    <xsl:template name="createMergeMethod">
        <xsl:call-template name="NewLine" />
        <xsl:text>    @Override</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>    public void merge(VaradaStatsBase varadaStatsBase)</xsl:text>
        <xsl:call-template name="NewLine" />
        <xsl:text>    {</xsl:text>
        <xsl:variable name="countItems" select="count(//Counter[@persistent='true'])"/>
        <xsl:if test="$countItems > 0">
            <xsl:call-template name="NewLine" />
            <xsl:text>        if (varadaStatsBase != null) {</xsl:text>
            <xsl:call-template name="NewLine" />

            <xsl:text>            </xsl:text>
            <xsl:call-template name="GenerateMetricClassName">
                <xsl:with-param name="fileName">
                    <xsl:value-of select="@Name" />
                </xsl:with-param>
            </xsl:call-template>
            <xsl:text> other = (</xsl:text>
            <xsl:call-template name="GenerateMetricClassName">
                <xsl:with-param name="fileName">
                    <xsl:value-of select="@Name" />
                </xsl:with-param>
            </xsl:call-template>
            <xsl:text>) varadaStatsBase;</xsl:text>
            <xsl:call-template name="NewLine" />
            <xsl:for-each select="Counter">
                <xsl:if test="attribute::persistent = 'true'">
                    <xsl:text>            longStruct.put(</xsl:text>
                    <xsl:value-of select="position() - 1" />
                    <xsl:text>, get</xsl:text>
                    <xsl:choose>
                        <xsl:when test="@Type='long' or @Type='double'">
                            <xsl:value-of select="@Name" />
                            <xsl:text>() + </xsl:text>
                            <xsl:text>other.get</xsl:text>
                            <xsl:value-of select="@Name" />
                            <xsl:text>());</xsl:text>
                        </xsl:when>
                        <xsl:when test="@Type='min' or @Type='max'">
                            <xsl:value-of select="@Type" /><xsl:text>_</xsl:text><xsl:value-of select="@Name" />
                            <xsl:text>() + </xsl:text>
                            <xsl:text>other.get</xsl:text>
                            <xsl:value-of select="@Type" /><xsl:text>_</xsl:text><xsl:value-of select="@Name" />
                            <xsl:text>());</xsl:text>
                        </xsl:when>
                    </xsl:choose>

                    <xsl:call-template name="NewLine" />
                </xsl:if>
            </xsl:for-each>
            <xsl:text>        }</xsl:text>
        </xsl:if>
        <xsl:call-template name="NewLine" />
        <xsl:text>    }</xsl:text>
        <xsl:call-template name="NewLine" />
    </xsl:template>
</xsl:stylesheet>


