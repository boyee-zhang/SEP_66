/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.instrumentation;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;
import io.trino.instrumentation.events.ConnectorAccessControlEvent;
import io.trino.instrumentation.events.ConnectorEvent;
import io.trino.instrumentation.events.ConnectorFactoryEvent;
import io.trino.instrumentation.events.ConnectorMetadataEvent;
import io.trino.instrumentation.events.ConnectorPageSinkEvent;
import io.trino.instrumentation.events.ConnectorPageSinkProviderEvent;
import io.trino.instrumentation.events.ConnectorPageSourceEvent;
import io.trino.instrumentation.events.ConnectorPageSourceProviderEvent;
import io.trino.instrumentation.events.ConnectorRecordSetProviderEvent;
import io.trino.instrumentation.events.RecordSetEvent;
import io.trino.instrumentation.events.SystemAccessControlEvent;
import io.trino.spi.connector.Connector;
import io.trino.spi.connector.ConnectorAccessControl;
import io.trino.spi.connector.ConnectorFactory;
import io.trino.spi.connector.ConnectorMetadata;
import io.trino.spi.connector.ConnectorPageSink;
import io.trino.spi.connector.ConnectorPageSinkProvider;
import io.trino.spi.connector.ConnectorPageSource;
import io.trino.spi.connector.ConnectorPageSourceProvider;
import io.trino.spi.connector.ConnectorRecordSetProvider;
import io.trino.spi.connector.ConnectorSecurityContext;
import io.trino.spi.connector.ConnectorSession;
import io.trino.spi.connector.RecordSet;
import io.trino.spi.security.SystemAccessControl;
import io.trino.spi.security.SystemSecurityContext;

import javax.lang.model.element.Modifier;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static java.lang.reflect.Modifier.isPrivate;
import static java.lang.reflect.Modifier.isProtected;
import static java.lang.reflect.Modifier.isPublic;
import static java.nio.file.Files.writeString;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public class InstrumentationGenerator
{
    private static final Set<Class<?>> KNOWN_INSTRUMENTED_CLASSES = Set.of(
            ConnectorMetadata.class,
            ConnectorFactory.class,
            Connector.class,
            ConnectorPageSink.class,
            ConnectorPageSourceProvider.class,
            ConnectorPageSinkProvider.class,
            ConnectorPageSource.class,
            ConnectorRecordSetProvider.class,
            RecordSet.class,
            ConnectorAccessControl.class);

    private static final String DELEGATE_VARIABLE = "delegate";
    private static final String DELEGATE_CLASS_NAME = "delegateClassName";
    private static final String CATALOG_NAME_VARIABLE = "catalogName";
    private static final String UNKNOWN_CATALOG_NAME = "unknown";
    private static final String EVENT_VARIABLE = "event";
    private static final String WRAPPING_METHOD = "instrument";

    public static final String MODULE_NAME = "lib/trino-instrumentation";
    public static final String CLASS_COMMENT = """
            This class has been generated by the InstrumentationGenerator class.
            The generation is a one-time event and is not repeated during build.
            """;

    public static final String IDENT = "    ";

    public static final String GENERATED_FILE_HEADER = """
    /*
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
            """;

    private InstrumentationGenerator() {}

    private static void generate(Class<?> interfaceClazz, Class<?> eventClazz, Function<Method, CodeBlock> eventInit, Function<Method, CodeBlock> eventPreCommit)
    {
        String generatedClassName = instrumentedClassName(interfaceClazz);

        TypeSpec.Builder mainClass = TypeSpec.classBuilder(generatedClassName)
                .addJavadoc(CLASS_COMMENT)
                .addSuperinterface(ClassName.get(interfaceClazz))
                .addModifiers(PUBLIC, FINAL)
                .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
                        .addMember("value", "{\"DeprecatedApi\", \"ExperimentalSpi\", \"DuplicatedCode\"}")
                        .build())
                .addField(FieldSpec.builder(String.class, CATALOG_NAME_VARIABLE, PRIVATE, FINAL).build())
                .addField(FieldSpec.builder(String.class, DELEGATE_CLASS_NAME, PRIVATE, FINAL).build())
                .addField(getDelegateField(interfaceClazz));

        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(PRIVATE)
                .addParameter(String.class, CATALOG_NAME_VARIABLE)
                .addParameter(ClassName.get(interfaceClazz), DELEGATE_VARIABLE)
                .addStatement("this.$1N = requireNonNull($1N, \"$1N is null\")", CATALOG_NAME_VARIABLE)
                .addStatement("this.$1N = requireNonNull($1N, \"$1N is null\")", DELEGATE_VARIABLE)
                .addStatement("this.$N = $N.getClass().getSimpleName()", DELEGATE_CLASS_NAME, DELEGATE_VARIABLE)
                .build();

        MethodSpec delegatorWithCatalogName = MethodSpec.methodBuilder(WRAPPING_METHOD)
                .addModifiers(PUBLIC, STATIC)
                .addParameter(String.class, CATALOG_NAME_VARIABLE)
                .addParameter(ClassName.get(interfaceClazz), DELEGATE_VARIABLE)
                .returns(ClassName.get(interfaceClazz.getPackageName(), interfaceClazz.getSimpleName()))
                .addCode("if ($L instanceof $L instrumented) {\n", DELEGATE_VARIABLE, generatedClassName)
                .addStatement("    return instrumented")
                .addCode("}\n")
                .addStatement("return new $L($L, $L)", generatedClassName, CATALOG_NAME_VARIABLE, DELEGATE_VARIABLE)
                .build();

        MethodSpec delegator = MethodSpec.methodBuilder(WRAPPING_METHOD)
                .addModifiers(PUBLIC, STATIC)
                .addParameter(ClassName.get(interfaceClazz), DELEGATE_VARIABLE)
                .returns(ClassName.get(interfaceClazz.getPackageName(), interfaceClazz.getSimpleName()))
                .addCode("if ($L instanceof $L instrumented) {\n", DELEGATE_VARIABLE, generatedClassName)
                .addStatement("    return instrumented")
                .addCode("}\n")
                .addStatement("return new $L($S, $L)", generatedClassName, UNKNOWN_CATALOG_NAME, DELEGATE_VARIABLE)
                .build();

        mainClass.addMethod(constructor);
        mainClass.addMethod(delegator);
        mainClass.addMethod(delegatorWithCatalogName);

        Set<Method> methods = gatherAllMethods(interfaceClazz);

        mainClass.addMethods(methods.stream()
                .map(method -> buildDelegatingMethod(eventClazz, method, eventInit, eventPreCommit))
                .collect(toImmutableSet()));

        JavaFile javaFile = JavaFile.builder(interfaceClazz.getPackageName(), mainClass.build())
                .addStaticImport(Objects.class, "requireNonNull")
                .indent(IDENT)
                .build();

        StringBuilder builder = new StringBuilder();
        builder.append(GENERATED_FILE_HEADER);

        try {
            javaFile.writeTo(builder);
            writeString(getSrcDir().resolve(getPackagePath(interfaceClazz)).resolve(generatedClassName + ".java"), builder.toString());
        }
        catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static String getPackagePath(Class<?> clazz)
    {
        return clazz.getPackage().getName().replace(".", "/");
    }

    private static MethodSpec buildDelegatingMethod(Class<?> eventClazz, Method method, Function<Method, CodeBlock> eventInit, Function<Method, CodeBlock> eventPreCommit)
    {
        return MethodSpec.methodBuilder(method.getName())
                .returns(method.getGenericReturnType())
                .addModifiers(getModifiers(method.getModifiers()))
                .addParameters(buildParameters(method.getParameters()))
                .addAnnotation(Override.class)
                .addExceptions(stream(method.getGenericExceptionTypes()).map(ClassName::get).collect(toImmutableList()))
                .addCode(instrumentedDelegation(eventClazz, method, eventInit, eventPreCommit))
                .build();
    }

    private static CodeBlock instrumentedDelegation(Class<?> eventClazz, Method method, Function<Method, CodeBlock> eventInit, Function<Method, CodeBlock> eventPreCommit)
    {
        String currentIdent = "";

        String params = stream(method.getParameters())
                .sequential()
                .map(Parameter::getName)
                .collect(joining(", "));

        boolean methodReturns = !method.getReturnType().equals(void.class);

        CodeBlock.Builder builder = CodeBlock.builder();

        builder.addStatement("final $T $L = new $T()", eventClazz, EVENT_VARIABLE, eventClazz);
        builder.add(eventInit.apply(method));
        builder.addStatement("$L.begin()", EVENT_VARIABLE);

        builder.add("try {\n");
        currentIdent += IDENT;

        if (methodReturns) {
            if (KNOWN_INSTRUMENTED_CLASSES.contains(method.getReturnType())) {
                builder.addStatement(currentIdent + " return $L($L, $L.$L($L))", instrumentationWrappingMethod(method.getReturnType()), CATALOG_NAME_VARIABLE, DELEGATE_VARIABLE, method.getName(), params);
            }
            else {
                builder.addStatement(currentIdent + " return $L.$L($L)", DELEGATE_VARIABLE, method.getName(), params);
            }
        }
        else {
            builder.addStatement(currentIdent + "$L.$L($L)", DELEGATE_VARIABLE, method.getName(), params);
        }

        builder.add("} finally {\n");

        builder.addStatement(currentIdent + "$L.end()", EVENT_VARIABLE);
        builder.add(currentIdent + "if ($L.shouldCommit()) {\n", EVENT_VARIABLE);
        builder.add(IDENT + eventPreCommit.apply(method));
        builder.addStatement(currentIdent + IDENT + "$L.commit()", EVENT_VARIABLE);
        builder.add(currentIdent + "}\n");
        builder.add("}");

        return builder.build();
    }

    private static String instrumentationWrappingMethod(Class<?> returnType)
    {
        return "%s.%s.%s".formatted(returnType.getPackage().getName(), instrumentedClassName(returnType), WRAPPING_METHOD);
    }

    private static String instrumentedClassName(Class<?> clazz)
    {
        return "Instrumented" + clazz.getSimpleName();
    }

    private static Iterable<ParameterSpec> buildParameters(Parameter[] parameters)
    {
        ImmutableList.Builder<ParameterSpec> specs = ImmutableList.builderWithExpectedSize(parameters.length);

        for (Parameter parameter : parameters) {
            specs.add(ParameterSpec.builder(parameter.getParameterizedType(), parameter.getName()).build());
        }

        return specs.build();
    }

    private static Set<Method> gatherAllMethods(Class<?> interfaceClazz)
    {
        ImmutableList.Builder<Method> builder = ImmutableList.builder();
        Set<Method> methods = stream(interfaceClazz.getMethods()).collect(toImmutableSet());
        builder.addAll(methods);

        for (Class<?> implemented : interfaceClazz.getInterfaces()) {
            Set<Method> subMethods = gatherAllMethods(implemented).stream().filter(method -> !methodDeclarationClashes(method, methods)).collect(toImmutableSet());
            builder.addAll(subMethods);
        }

        return ImmutableSet.copyOf(builder.build());
    }

    private static boolean methodDeclarationClashes(Method method, Set<Method> superMethods)
    {
        for (Method superMethod : superMethods) {
            if (method.getName().equals(superMethod.getName()) && Arrays.equals(method.getParameterTypes(), superMethod.getParameterTypes())) {
                return true;
            }
        }

        return false;
    }

    private static FieldSpec getDelegateField(Class<?> interfaceImplemented)
    {
        return FieldSpec.builder(ClassName.get(interfaceImplemented), DELEGATE_VARIABLE, PRIVATE, FINAL).build();
    }

    private static Set<Modifier> getModifiers(int modifiers)
    {
        ImmutableSet.Builder<Modifier> builder = ImmutableSet.builder();

        if (isPrivate(modifiers) || isProtected(modifiers)) {
            throw new RuntimeException("Cannot delegate to private/protected methods");
        }

        if (isPublic(modifiers)) {
            builder.add(PUBLIC);
        }

        return builder.build();
    }

    private static CodeBlock setMethodAndCatalog(Method method)
    {
        return CodeBlock.builder()
                .add("if ($L.isEnabled()) {\n", EVENT_VARIABLE)
                .addStatement(IDENT + "$L.className = $L", EVENT_VARIABLE, DELEGATE_CLASS_NAME)
                .addStatement(IDENT + "$L.method = $S", EVENT_VARIABLE, method.getName())
                .addStatement(IDENT + "$L.catalogName = $L", EVENT_VARIABLE, CATALOG_NAME_VARIABLE)
                .add("}\n")
                .build();
    }

    private static Optional<Parameter> findParameter(Method method, Predicate<Parameter> predicate)
    {
        return stream(method.getParameters()).filter(predicate).findFirst();
    }

    private static CodeBlock setQueryId(Method method)
    {
        CodeBlock.Builder builder = CodeBlock.builder();
        Optional<Parameter> connectorSession = findParameter(method, parameter -> parameter.getType().equals(ConnectorSession.class));
        connectorSession.ifPresent(parameter -> builder.addStatement("$L.queryId = $L.getQueryId()", EVENT_VARIABLE, parameter.getName()));
        return builder.build();
    }

    private static CodeBlock setQueryIdFromSecurityContext(Method method)
    {
        CodeBlock.Builder builder = CodeBlock.builder();
        Optional<Parameter> securityContext = findParameter(method, parameter -> parameter.getType().equals(ConnectorSecurityContext.class));
        securityContext.ifPresent(parameter -> builder.addStatement("$L.queryId = $L.getQueryId().getId()", EVENT_VARIABLE, parameter.getName()));
        return builder.build();
    }

    private static CodeBlock setQueryIdFromSystemSecurityContext(Method method)
    {
        CodeBlock.Builder builder = CodeBlock.builder();
        Optional<Parameter> securityContext = findParameter(method, parameter -> parameter.getType().equals(SystemSecurityContext.class));
        securityContext.ifPresent(parameter -> builder.addStatement("$L.getQueryId().ifPresent(queryId -> $L.queryId = queryId.getId())", parameter.getName(), EVENT_VARIABLE));
        return builder.build();
    }

    private static Path getSrcDir()
    {
        return Paths.get(MODULE_NAME)
                .resolve("src")
                .resolve("main")
                .resolve("java");
    }

    public static void main(String[] args)
    {
        // Connector SPIs
        generate(Connector.class, ConnectorEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorMetadata.class, ConnectorMetadataEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorPageSource.class, ConnectorPageSourceEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorPageSourceProvider.class, ConnectorPageSourceEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorPageSink.class, ConnectorPageSinkEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorPageSinkProvider.class, ConnectorPageSinkProviderEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorAccessControl.class, ConnectorAccessControlEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryIdFromSecurityContext);
        generate(ConnectorPageSourceProvider.class, ConnectorPageSourceProviderEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorRecordSetProvider.class, ConnectorRecordSetProviderEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(RecordSet.class, RecordSetEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        generate(ConnectorFactory.class, ConnectorFactoryEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryId);
        // Engine SPIs
        generate(SystemAccessControl.class, SystemAccessControlEvent.class, InstrumentationGenerator::setMethodAndCatalog, InstrumentationGenerator::setQueryIdFromSystemSecurityContext);
    }
}
